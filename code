#!/bin/bash

code() {
    # usage: code <path>
    local target="${1:-.}"

    # WSL view of Code - Insiders location
    local exe="/mnt/c/Program Files/Microsoft VS Code Insiders/Code - Insiders.exe"

    if [ ! -f "$exe" ]; then
        printf 'Error: "Code - Insiders.exe" not found at %s.\n' "$exe"
        return 2
    fi

    # Open via VS Code's WSL Remote extension by passing a vscode-remote:// URI.
    # This keeps WSL semantics (including symlinks) instead of converting to a Windows path.
    local distro="${WSL_DISTRO_NAME:-}"
    if [ -z "$distro" ]; then
        printf 'Error: WSL_DISTRO_NAME is not set. Are you running inside WSL?\n' >&2
        return 4
    fi

    # Convert target into a WSL path (do NOT resolve symlinks).
    local wsl_target="$target"
    case "$target" in
        [A-Za-z]:\\*)
            if command -v wslpath >/dev/null 2>&1; then
                wsl_target="$(wslpath -u "$target" 2>/dev/null || printf '%s' "$target")"
            else
                printf 'Error: wslpath not found; cannot convert Windows path "%s" to WSL.\n' "$target" >&2
                return 5
            fi
            ;;
        /*)
            ;; # already absolute WSL path
        *)
            # Build a logical absolute path using $PWD to preserve symlinks in the working directory.
            wsl_target="${PWD%/}/$target"
            ;;
    esac

    if [ ! -e "$wsl_target" ]; then
        printf 'Warning: target "%s" does not exist in WSL filesystem. Passing value through.\n' "$wsl_target" >&2
    fi

    # Percent-encode a string for use in a URI path, keeping '/' unescaped.
    _code_uri_escape_path() {
        # Avoid bash-only substring operators so this works when sourced from other shells.
        # Encode by bytes (ASCII/UTF-8) using od.
        local s="$1" hex out="" upper

        while IFS= read -r hex; do
            case "$hex" in
                ''|*[!0-9a-fA-F]*)
                    continue
                    ;;
            esac

            case "$hex" in
                2f|2d|2e|5f|7e|3[0-9]|4[1-9a-fA-F]|5[0-9a-fA-F]|6[1-9a-fA-F]|7[0-9a-fA-F])
                    # Safe: / - . _ ~ 0-9 A-Z a-z
                    out+="$(printf "\\x$hex")"
                    ;;
                *)
                    upper="$(printf '%s' "$hex" | tr '[:lower:]' '[:upper:]')"
                    out+="%$upper"
                    ;;
            esac
        done < <(LC_ALL=C printf '%s' "$s" | od -An -tx1 -v | tr -s ' ' '\n')

        printf '%s' "$out"
    }

    # Distro names are typically safe, but escape spaces etc for the authority portion.
    # We reuse the same escaper and just strip '/' (should never appear in distro names).
    local authority="wsl+$(_code_uri_escape_path "$distro")"
    authority="${authority//\//}"

    # Ensure path begins with '/'
    case "$wsl_target" in
        /*) ;;
        *) wsl_target="/$wsl_target" ;;
    esac

    local uri_path
    uri_path="$(_code_uri_escape_path "$wsl_target")"
    local uri="vscode-remote://$authority$uri_path"

    local uri_flag="--file-uri"
    if [ -d "$wsl_target" ] || [[ "$target" == */ ]]; then
        uri_flag="--folder-uri"
    fi

    # Always print the URI so it's obvious what VS Code is opening.
    printf '%s\n' "$uri"

    # Launch (quote everything to handle spaces). Run in background so shell isn't blocked.
    "$exe" "$uri_flag" "$uri" >/dev/null 2>&1 &
    local launch_status=$?
    local pid=$!

    if (( launch_status != 0 )); then
        printf 'Error: Failed to launch "%s" with URI "%s".\n' "$exe" "$uri"
        return 3
    fi

    builtin disown "$pid" 2>/dev/null || true

    return 0
}
